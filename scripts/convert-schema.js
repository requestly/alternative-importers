#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const jsonRefs = require('json-refs');
const { jsonSchemaToZod } = require('json-schema-to-zod');

const filename = process.argv[2];

if (!filename) {
  console.error('‚ùå Error: No filename provided');
  console.log('\nUsage: npm run schema:convert <filename>');
  console.log('Example: npm run schema:convert postman_collection_2_1');
  process.exit(1);
}

// Remove .json extension if provided
const baseFilename = filename.replace(/\.json$/, '');

const inputPath = path.join('src', 'schemas', 'json-schemas', `${baseFilename}.json`);
const outputPath = path.join('src', 'schemas', 'zod-schemas', `${baseFilename}.ts`);

// Check if input file exists
if (!fs.existsSync(inputPath)) {
  console.error(`‚ùå Error: File not found: ${inputPath}`);
  process.exit(1);
}

// Create output directory if it doesn't exist
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

console.log(`üìÑ Converting: ${inputPath}`);
console.log(`üìù Output to: ${outputPath}`);

/**
 * Custom parser override to handle oneOf as z.union() instead of superRefine
 * This improves type inference and performance by treating oneOf as anyOf
 */
function customOneOfParser(schema, refs) {
  // Only handle schemas that have oneOf
  if (!schema.oneOf || !Array.isArray(schema.oneOf)) {
    return; // Return undefined to use default parser
  }
  
  // Convert each oneOf branch to Zod independently
  const parsedBranches = schema.oneOf.map((subSchema) => {
    // Generate Zod code for each branch, passing the same parser override
    // so nested oneOf instances also get converted to z.union()
    const branchCode = jsonSchemaToZod(subSchema, {
      module: 'none',
      noImport: true,
      parserOverride: customOneOfParser, // Recursive: handle nested oneOf
    });
    
    // Remove any trailing semicolons and whitespace
    return branchCode.trim().replace(/;$/, '');
  });
  
  // Handle single branch case
  if (parsedBranches.length === 1) {
    return parsedBranches[0];
  }
  
  // Create union with all branches
  return `z.union([${parsedBranches.join(', ')}])`;
}

async function convertSchema() {
  try {
    // Step 1: Read and resolve JSON refs
    console.log('üîÑ Resolving JSON references...');
    const schemaContent = fs.readFileSync(inputPath, 'utf8');
    const schema = JSON.parse(schemaContent);
    
    const result = await jsonRefs.resolveRefs(schema);
    const resolvedSchema = result.resolved;
    
    // Step 2: Convert to Zod with custom parser override
    console.log('üîÑ Converting to Zod schema with custom oneOf handler...');
    const zodCode = jsonSchemaToZod(resolvedSchema, {
      module: 'esm',
      parserOverride: customOneOfParser,
    });
    
    // Add header comment indicating auto-generation
    const headerComment = `/**
 * This file is auto-generated using the schema conversion script.
 * Source schema: ${inputPath}
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Run 'npm run schema:convert ${baseFilename}' to regenerate.
 */

`;
    const zodCodeWithHeader = headerComment + zodCode;
    
    // Step 3: Format with Prettier
    console.log('üîÑ Formatting with Prettier...');
    const tempFile = outputPath + '.tmp';
    fs.writeFileSync(tempFile, zodCodeWithHeader);
    
    execSync(
      `prettier --parser typescript "${tempFile}" > "${outputPath}"`,
      { stdio: 'inherit', shell: true }
    );
    
    // Clean up temp file
    fs.unlinkSync(tempFile);
    
    console.log('‚úÖ Schema conversion completed successfully!');
    console.log('üí° Using z.union() for oneOf (better type inference & performance)');
  } catch (error) {
    console.error('‚ùå Error during conversion:', error.message);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

convertSchema();
